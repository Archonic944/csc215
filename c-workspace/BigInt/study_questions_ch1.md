# Study Questions (p3-4)

1. Suppose you want to add unary operations (i.e., ones requiring only one
operand) to the calculator. For example, we might add "M" to indicate
unary minus (i.e., change the sign of the old value) and "A" to indicate
absolute value. What changes would need to be made to the program?

We would need to implement a branch of the parser code that checks the operation early, and if it is a unary operation, performs that operation immediately instead of parsing another number.

2. Suppose that words rather than single character symbols are to be used
for the operators (e.g., the user types "times" instead of "*"). Where in
the program would the necessary changes occur?

In the operation parsing, we would need to parse a string instead of a character. It wouldn't be that hard, since our program is already line-oriented. We would have to allocate a char array, and use a null terminator to represent its end.

3. Suppose that the calculator is to be converted to use C++ double values
rather than integers. Where would changes need to be made?

Well, we would no longer have to worry about overflows (for the most part). The only thing that would really change is, once again, the code that parses numbers, as we would need to use a function to parse a floating point number instead of parsing an integer.

5. Show how a new command, "C", which acts like the "Clear" command on
a calculator could be implemented. The clear command sets the current
value to zero.

We would have to change the prompt to "enter a value or command." Then, the user could either enter C or a number; entering C would set the value to 0 and continue the loop.

6. (AB only) How could the calculator be modified to allow the use of
parentheses to control the order of operations?

We could use a stack that stores open parenthesis locations. Encountering a close parenthesis would pop that stack and evaluate the expression fragment.

# Page 6

1. What are the largest and smallest integer values in the programming
environment you use?

In CP/M; 32767 and -32768

2. Each BigInt object will need to store the digits that represent the BigInt
value. The decision to allow arbitrarily large BigInt values affects the
choices for storing digits. Name one method for storing digits that will
permit an arbitrary number of digits to be stored. What effect would
a limit on the number of digits in a BigInt have in the design of the
BigInt class?

A limit of the number of digits would make the class less versatile, and kind of useless. We could use a byte array to store digits.

3. Based on your knowledge of pencil-and-paper methods for doing
arithmetic, what do you think will be the most difficult arithmetic
operation (+, *, -) to implement for the BigInt class? Why?

Probably multiplication because it requires more steps than adddition and subtraction.

4. Experiment with the calculator. If you enter abcd1234 when a number
is expected, what happens? If you enter 1234abcd is the behavior
different? What happens if you enter an operator that’s not one of the
three that are implemented?
5. List as many operations as you can that are performed on integers, but
that are not included in the list of BigInt functions and operators above.

- Left shift
- Right shift
- Divide

6. (AB only) What implementation decisions would require providing a
destructor, a copy constructor, and an assignment operator?

- Freeing memory?

7. Consider the headers for operator- and operator+ given below.
BigInt operator - (const BigInt & big, int small);
// postcondition: returns big - small
BigInt operator + (const BigInt & big, int small);
// postcondition: returns big + small
Write the body of operator- assuming that operator+ has been written.

Haven't read the code yet, but you would negate the small integer then add the two.

# Page 10

1. I don't know about diving by zero, but I know that there are no exceptions in this version of C. So the program would return a special value for most errors.

2. List several errors that might be generated by BigInt operations and
develop a declaration for an enumerated type (enum) to hold the errors

enum BigIntError {
    DIVIDE_BY_ZERO,
    OVERFLOW,
    UNDERFLOW,
    INVALID_OPERATION
};

3. Some systems allow error checking to be “turned off” entirely for greater
speed. Under what circumstances is this approach preferred?

A very competent programmer working in a controlled environment might prefer this approach for speed.

4. Consider another method for handling errors:
Use an interactive error-handling approach. An error message is
displayed to the user who then has the option of (a) correcting the
value that caused the error, (b) halting the program, or (c) ignoring
the error.

A strength of this approach is that it makes the program more versatile, and almost completely unlikely to fail. A weakness is that the user-friendliness dramatically decreases, as the user is now forced to manage an under-the-hood abstraction. This is completely unacceptable. BigInt is designed for programmers, not end-users.

5. Consider another method for handling errors:
Error results are stored in a single global variable. This is set
initially to indicate a “no error” condition. Whenever an error is
detected, the global variable is set to an appropriate value, and
the client program is responsible for examining the value of the
global variable.
Describe the strengths and weaknesses of this approach.

The strength is that this doesn't require an exception handling system, and still allows us to branch based on errors. The weakness is that we would have to check the global variable after every operation, which is tedious and error-prone.

